----
title: О модулях
prevChapter: /ru/miscellaneous/index.html
nextChapter: /ru/miscellaneous/pattern-matching.html
----

Как вы помните, в самом начале мы уже немного говорили о модулях. Пришло время изучить их более основательно.

## Об иерархии

Зайдём в каталог `src`, создадим в нём подкаталог `Utils` и разместим в нём файл `Helpers.hs`. Откроем и напишем следующее:
 
```haskell
module Utils.Helpers (
    calibrate,
    graduate
) where

coefficient :: Double
coefficient = 0.99874

calibrate length = length * coefficient

graduate length = length / coefficient
```

Имя модуля не просто `Helpers`, а `Utils.Helpers`, то есть оно теперь отражает иерархию наших исходников. И хотя мы можем и не делать этого, но общая практика в мире Haskell именно такова: указывать имя модуля с полным путём к нему от корня проекта. Именно поэтому все модули, которые мы уже использовали, именовались полным путём, например:

```haskell
import Data.String.Utils
```

Теперь вы знаете, что подобное длинное название - это всего лишь путь: в исходниках данного пакета есть каталог `Data`, в нём - подкаталог `String`, а уже в нём лежит модуль `Utils.hs`.

## О лице

У каждого модуля, помимо имени, есть и лицо (или, если угодно, интерфейс). Интерфейс - это набор всего того, что может быть импортировано в другие модули. По умолчанию всё содержимое модуля является его интерфейсом и поэтому доступно всему миру. Однако в реальных модулях у вас, скорее всего, будут некоторые служебные функции и типы, которые вы не захотите показывать всем.

Взглянем ещё раз на начало модуля `Utils.Helpers`:

```haskell
module Utils.Helpers (
    calibrate,
    graduate
) where
```

Вы уже видели такие круглые скобки, теперь же вы знаете, что это и есть интерфейс нашего модуля, поэтому только эти две функции можно будет импортировать. Всё остальное, что есть в этом модуле, останется тайной за семью печатями. В частности, наше служебное значение `coefficient`: при попытке импортировать его в другой модуль компилятор удивлённо упрекнёт вас, мол, не знаю я никакого `coefficient`. Но если оно окажется кому-то нужным - допишем его имя в круглых скобках:

```haskell
module Utils.Helpers (
    calibrate,
    graduate,
    coefficient
) where
```

и всё заработает. Теперь пропишем в лице модуля наш собственный тип:

```haskell
module Utils.Helpers (
    calibrate,
    graduate,
    Color (Red, Green, Blue)
) where

data Color = Red | Green | Blue deriving Show
```

Обратите внимание: недостаточно прописать в лице модуля имя типа, необходимо также перечислить его конструкторы в виде кортежа. Впрочем, достаточно перечислить лишь те конструкторы, которые вы реально собираетесь использовать в других модулях для создания значений типа `Color`.

## Ничего, кроме...

В ряде случаев вам нельзя (или необязательно) импортировать всё то, что есть в модуле. Откроем `app/Main.hs` и напишем в нём:

```haskell
import Utils.Helpers (calibrate)  -- Импортируем только calibrate. 

main :: IO ()
main = print $ calibrate 12.4
```

Мы импортировали лишь то, что перечислено в виде кортежа сразу за именем модуля. Всё остальное содержимое `Utils.Helpers` осталось невидимым.

Вы спросите, зачем это нужно? В конце концов, ну и пусть импортируется всё, а уж мы решим, что нам использовать.

Главная цель частичного импорта - исключение конфликта имён. В разных модулях зачастую присутствуют одноимённые сущности. В этом случае мы можем взять из "конфликтных" модулей только то, что нам необходимо.

## Всё, кроме...

Существует также противоположный подход, а именно частичный импорт всего содержимого модуля, кроме указанного. В этом случае нам понадобится ключевое слово `hiding`:

```haskell
import Utils.Helpers hiding (graduate)  -- graduate скрыта.  
```

После слова `hiding` перечислены в виде кортежа те сущности, которые будут недоступны (скрыты) в текущем модуле. Как вы уже догадались, такой подход так же используется во избежание конфликтов между одноимёнными сущностями из разных модулей.

## Принадлежность

В реальных проектах вы столкнётесь с ситуацией, когда вам очень нужно будет совместно использовать одноимённые функции из разных модулей. Просто так это сделать не получится, компилятор проявит принципиальность и потребует уточнений. В этом случае нам необходимо явно указать принадлежность функции к конкретному модулю:

```haskell
import Utils.Helpers
import Utils.Math  -- А вдруг здесь тоже есть функция calibrate?

main :: IO ()
main = print $ Utils.Helpers.calibrate 12.4
```

В этом случае конфликта не будет.

## Короткая принадлежность

В уже известном нам пакете `MissingH` есть модули с весьма длинным именем, например `System.Console.GetOpt.Utils`. Согласитесь, длинновато писать такой "префикс" всякий раз, когда нужно указать принадлежность. К счастью, есть способ ввести короткий псевдоним для модуля:

```haskell
import Utils.Helpers as H

main :: IO ()
main = print $ H.graduate 23
```

Ключевое слово as вводит короткое имя для `Utils.Helpers`. Кстати, на это имя действует общее для всех типов правило: только с большой буквы. Поэтому такой вариант не пройдёт:

```haskell
import Utils.Helpers as h
```

## Обязательная принадлежность

В ряде случаев бывает полезным призвать пользователя к строгому порядку и обязать его указывать принадлежность сущностей к модулю. Например:

```haskell
import qualified Utils.Helpers as H 

main :: IO ()
main = print $ graduate 23
```

Мы импортировали наш модуль с ключевым словом qualified. Именно поэтому такой код не пройдёт компиляцию. Слово `qualified` обязывает нас уточнять принадлежность всех используемых сущностей к соответствующим им модулям. Поэтому даже если функция graduate представлена в единственном экземпляре, при `qualified`-импорте мы должны явно указать, к какому модулю она принадлежит:

```haskell
print $ H.graduate 23
```

Ну вот, теперь вы знаете о модулях практически всё.
