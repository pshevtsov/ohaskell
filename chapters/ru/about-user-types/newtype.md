----
title: Новый тип
prevChapter: /ru/about-user-types/own-type-classes.html
nextChapter: /ru/io/index.html
----

Помимо ключевого ключевого `data` существует ещё одно слово, предназначенное для определения нового типа. Оно так и называется - `newtype`. И между этими двумя словами есть несколько важных отличий.

## Один конструктор значения

Тип, определяемый с помощью слова `newtype`, может иметь один и только один конструктор значения. Мы можем написать так:
 
```haskell
newtype IPAddress = IP String
                    deriving Show
```

а вот такой код будет категорически отвергнут компилятором:

```haskell
newtype IPAddress = IP String | Host String
                    deriving Show
```

## Одно поле

Следующее ограничение: одно и только одно поле. Мы можем написать так:

```haskell
newtype IPAddress = IP String
                    deriving Show
```

или так:

```haskell
newtype IPAddress = IP { value :: String }
                    deriving Show
```

А вот такой код не будет принят компилятором:

```haskell
newtype IPAddress = IP String Int
                    deriving Show
```

Тип с нульарным конструктором тоже не пройдёт компиляцию:

```haskell
newtype Color = Red
```

## Для чего он нужен

Вы спросите, зачем же нужно слово `newtype`, если с ним связаны такие ограничения? И чем вообще обусловлены эти ограничения?

Фундаментальное назначение `newtype`, строго говоря, не в том, чтобы создавать новый тип, а в том, чтобы оборачивать один, уже существующий тип. Именно поэтому оно требует унарного конструктора значения и никакого иного. Грубо говоря, слово `newtype` может рассматриваться как нечто среднее между словами `data` и `type`. И это даёт нам одно преимущество, а именно эффективность времени выполнения.

Если мы определили вот такой тип:

```haskell
data IPAddress = IP String
```

то с точки зрения программиста мы всего лишь обернули строковое значение в именную обёртку. Однако с точки зрения компилятора мы создали совершенно новый тип, хранящий в себе значение стандартного типа `String`. Поэтому работа с такой именной обёрткой связана с дополнительными накладными расходами на стадии выполнения (обусловленными "оборачиванием" и "разворачиванием" той самой внутренней строки). Да, эти расходы крошечны, но всё же...

Если же мы написали так:

```haskell
newtype IPAddress = IP String
```

мы сказали компилятору: "`IPAddress` - это всего лишь именная обёртка вокруг строки. Именно так её и воспринимай, и никаких лишних телодвижений не делай". Поэтому работа с таким типом будет чуток более эффективной.

## В сухом остатке

1. Ключевое слово `newtype` создаёт тип-обёртку вокруг некоторого уже существующего типа.
2. Эта тип-обёртка должна иметь только одно поле и только один конструктор значения.
3. Работа с типом, созданным с помощью `newtype`, эффективнее, нежели с созданным с помощью `data`.


